"use client";

import { useRef, useEffect } from "react";
import { useTheme } from "../themeProvider";

const vertexShader = `
  attribute vec2 a_position;
  void main() {
    gl_Position = vec4(a_position, 0.0, 1.0);
  }
`;

const fragmentShader = `
  precision highp float;
  
  uniform float u_time;
  uniform vec2 u_resolution;
  uniform vec3 u_color;
  uniform float u_aspect;
  
  #define PI 3.14159265359
  
  float hash(float n) {
    return fract(sin(n) * 43758.5453);
  }
  
  vec3 rotateY(vec3 p, float a) {
    float c = cos(a), s = sin(a);
    return vec3(c * p.x + s * p.z, p.y, -s * p.x + c * p.z);
  }
  
  vec3 rotateX(vec3 p, float a) {
    float c = cos(a), s = sin(a);
    return vec3(p.x, c * p.y - s * p.z, s * p.y + c * p.z);
  }
  
  float glow(float d, float radius, float intensity) {
    return radius / (d * d * intensity + radius);
  }
  
  vec2 project(vec3 p) {
    float perspective = 1.0 / (3.0 - p.z * 0.8);
    return p.xy * perspective;
  }
  
  float lineSeg(vec2 uv, vec2 a, vec2 b, float depth) {
    vec2 ba = b - a;
    vec2 ua = uv - a;
    float h = clamp(dot(ua, ba) / dot(ba, ba), 0.0, 1.0);
    float d = length(ua - ba * h);
    float core = smoothstep(0.015, 0.004, d) * depth;
    float g = glow(d, 0.004, 300.0) * depth * 0.5;
    return core + g;
  }
  
  void main() {
    vec2 uv = gl_FragCoord.xy / u_resolution;
    uv = uv * 2.0 - 1.0;
    uv.x *= u_aspect;
    
    float rotY = u_time * 0.4;
    float rotX = 0.5;
    
    float totalGlow = 0.0;
    float threatLevel = 0.0;
    float s = 0.3;
    
    // Cube vertices
    vec3 v0 = rotateX(rotateY(vec3(-s, -s, -s), rotY), rotX);
    vec3 v1 = rotateX(rotateY(vec3( s, -s, -s), rotY), rotX);
    vec3 v2 = rotateX(rotateY(vec3( s, -s,  s), rotY), rotX);
    vec3 v3 = rotateX(rotateY(vec3(-s, -s,  s), rotY), rotX);
    vec3 v4 = rotateX(rotateY(vec3(-s,  s, -s), rotY), rotX);
    vec3 v5 = rotateX(rotateY(vec3( s,  s, -s), rotY), rotX);
    vec3 v6 = rotateX(rotateY(vec3( s,  s,  s), rotY), rotX);
    vec3 v7 = rotateX(rotateY(vec3(-s,  s,  s), rotY), rotX);
    
    // Project vertices
    vec2 p0 = project(v0); vec2 p1 = project(v1);
    vec2 p2 = project(v2); vec2 p3 = project(v3);
    vec2 p4 = project(v4); vec2 p5 = project(v5);
    vec2 p6 = project(v6); vec2 p7 = project(v7);
    
    // Draw edges
    totalGlow += lineSeg(uv, p0, p1, 0.7);
    totalGlow += lineSeg(uv, p1, p2, 0.7);
    totalGlow += lineSeg(uv, p2, p3, 0.7);
    totalGlow += lineSeg(uv, p3, p0, 0.7);
    totalGlow += lineSeg(uv, p4, p5, 0.9);
    totalGlow += lineSeg(uv, p5, p6, 0.9);
    totalGlow += lineSeg(uv, p6, p7, 0.9);
    totalGlow += lineSeg(uv, p7, p4, 0.9);
    totalGlow += lineSeg(uv, p0, p4, 0.8);
    totalGlow += lineSeg(uv, p1, p5, 0.8);
    totalGlow += lineSeg(uv, p2, p6, 0.8);
    totalGlow += lineSeg(uv, p3, p7, 0.8);
    
    // Corner nodes
    float d0 = length(uv - p0); totalGlow += smoothstep(0.03, 0.015, d0) * 0.5;
    float d1 = length(uv - p1); totalGlow += smoothstep(0.03, 0.015, d1) * 0.5;
    float d2 = length(uv - p2); totalGlow += smoothstep(0.03, 0.015, d2) * 0.5;
    float d3 = length(uv - p3); totalGlow += smoothstep(0.03, 0.015, d3) * 0.5;
    float d4 = length(uv - p4); totalGlow += smoothstep(0.03, 0.015, d4) * 0.6;
    float d5 = length(uv - p5); totalGlow += smoothstep(0.03, 0.015, d5) * 0.6;
    float d6 = length(uv - p6); totalGlow += smoothstep(0.03, 0.015, d6) * 0.6;
    float d7 = length(uv - p7); totalGlow += smoothstep(0.03, 0.015, d7) * 0.6;
    
    // Attack particles - 8 particles
    for (int i = 0; i < 8; i++) {
      float id = float(i);
      float cycleTime = 3.5 + hash(id) * 1.5;
      float localTime = mod(u_time + hash(id + 50.0) * cycleTime, cycleTime);
      float progress = localTime / cycleTime;
      
      float theta = hash(id + 100.0) * 6.28;
      float phi = (hash(id + 150.0) - 0.5) * 2.5;
      
      vec3 dir = normalize(vec3(cos(theta) * cos(phi), sin(phi), sin(theta) * cos(phi)));
      
      float penetrates = step(0.7, hash(id + 200.0));
      
      float dist = mix(1.0, -0.2 * penetrates, progress);
      vec3 particlePos = dir * dist;
      
      particlePos = rotateX(rotateY(particlePos, rotY), rotX);
      vec2 proj = project(particlePos);
      
      float pd = length(uv - proj);
      float brightness = sin(progress * PI) * 0.8;
      
      float particleGlow = smoothstep(0.035, 0.01, pd) * brightness;
      particleGlow += glow(pd, 0.005, 300.0) * brightness * 0.4;
      
      totalGlow += particleGlow;
      
      // Threat when penetrating and near center
      if (penetrates > 0.5 && dist < 0.4 && dist > -0.1) {
        threatLevel += brightness * 0.2;
      }
    }
    
    // Edge fade
    vec2 edgeUV = gl_FragCoord.xy / u_resolution;
    float edgeFade = smoothstep(0.0, 0.1, edgeUV.x) * smoothstep(1.0, 0.9, edgeUV.x) *
                     smoothstep(0.0, 0.1, edgeUV.y) * smoothstep(1.0, 0.9, edgeUV.y);
    totalGlow *= edgeFade;
    threatLevel *= edgeFade;
    
    // Color mixing
    vec3 threatColor = vec3(1.0, 0.15, 0.1);
    vec3 col = mix(u_color, threatColor, clamp(threatLevel, 0.0, 0.7)) * totalGlow;
    
    col *= sin(gl_FragCoord.y * 1.5) * 0.03 + 0.97;
    col = col / (col + 0.5);
    
    float alpha = min(1.0, totalGlow * 1.2) * edgeFade;
    
    gl_FragColor = vec4(col, alpha);
  }
`;

function hexToRgb(hex: string): [number, number, number] {
  hex = hex.replace("#", "");
  const r = parseInt(hex.substring(0, 2), 16) / 255;
  const g = parseInt(hex.substring(2, 4), 16) / 255;
  const b = parseInt(hex.substring(4, 6), 16) / 255;
  return [r, g, b];
}

interface PentestCubeProps {
  className?: string;
}

export default function PentestCube({ className = "" }: PentestCubeProps) {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const animationRef = useRef<number>(0);
  const startTimeRef = useRef<number>(0);
  const { theme } = useTheme();

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas || !theme) return;

    const gl = canvas.getContext("webgl", {
      premultipliedAlpha: true,
      alpha: true,
      antialias: true,
    });
    if (!gl) return;

    const resize = () => {
      const dpr = Math.min(window.devicePixelRatio, 2);
      canvas.width = canvas.clientWidth * dpr;
      canvas.height = canvas.clientHeight * dpr;
      gl.viewport(0, 0, canvas.width, canvas.height);
    };
    resize();
    window.addEventListener("resize", resize);

    const vShader = gl.createShader(gl.VERTEX_SHADER)!;
    gl.shaderSource(vShader, vertexShader);
    gl.compileShader(vShader);

    const fShader = gl.createShader(gl.FRAGMENT_SHADER)!;
    gl.shaderSource(fShader, fragmentShader);
    gl.compileShader(fShader);

    if (!gl.getShaderParameter(fShader, gl.COMPILE_STATUS)) {
      console.error("Fragment shader error:", gl.getShaderInfoLog(fShader));
      return;
    }

    const program = gl.createProgram()!;
    gl.attachShader(program, vShader);
    gl.attachShader(program, fShader);
    gl.linkProgram(program);
    gl.useProgram(program);

    const positions = new Float32Array([
      -1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1,
    ]);
    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

    const posLoc = gl.getAttribLocation(program, "a_position");
    gl.enableVertexAttribArray(posLoc);
    gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

    const timeLoc = gl.getUniformLocation(program, "u_time");
    const resolutionLoc = gl.getUniformLocation(program, "u_resolution");
    const colorLoc = gl.getUniformLocation(program, "u_color");
    const aspectLoc = gl.getUniformLocation(program, "u_aspect");

    const [r, g, b] = hexToRgb(theme.config.shader || theme.config.primary);
    startTimeRef.current = performance.now();

    const render = () => {
      const time = (performance.now() - startTimeRef.current) / 1000;
      const aspect = canvas.width / canvas.height;

      gl.clearColor(0, 0, 0, 0);
      gl.clear(gl.COLOR_BUFFER_BIT);
      gl.useProgram(program);

      gl.uniform1f(timeLoc, time);
      gl.uniform2f(resolutionLoc, canvas.width, canvas.height);
      gl.uniform3f(colorLoc, r, g, b);
      gl.uniform1f(aspectLoc, aspect);

      gl.drawArrays(gl.TRIANGLES, 0, 6);
      animationRef.current = requestAnimationFrame(render);
    };

    render();

    return () => {
      window.removeEventListener("resize", resize);
      cancelAnimationFrame(animationRef.current);
      gl.deleteProgram(program);
      gl.deleteShader(vShader);
      gl.deleteShader(fShader);
    };
  }, [theme]);

  return (
    <canvas
      ref={canvasRef}
      className={`w-full h-full ${className}`}
      style={{ background: "transparent" }}
    />
  );
}
